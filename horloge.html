<!DOCTYPE html>

<!--
    Nom                     |    id ssh     |       matricule   |
----------------------------------------------------------------|
Matthieu Beauchamp-Boulay   |   beaumatt    |       20234205    |
Zacharie Martel             |   martelza    |       20231059    |
Émile-Jacob Le Blanc        |   leblanej    |       20188645    |
Lien Miro:  https://miro.com/app/board/uXjVO9MT7jA=/
-->

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Horloge</title>

    <!-- Define our functions here -->
    <!-- getTime() void function, changes time in html document -->
    <script>
        window.onload = init;


        // Initializers //////////////////////////////////////////////////////

        function init() {
            initPrimitives();

            makeClock();    // makes the hours/minutes/seconds


            updateTime();
            getMeteo();


            let i = 0
            setInterval(function () {
                i++
                moon_scaling(i/1000)
            }, 10)


            setInterval(updateTime, 1000);          // every second
            setInterval(getMsg, 1000);              // every second
            setInterval(getMeteo, 1000 * 60 * 60);  // every hour
        }

        function initPrimitives() {
            finishSun();
        }

        //////////////////////////////////////////////////////////////////////


        // Updaters (macro) //////////////////////////////////////////////////

        function updateTime() {
            let time = getTime()

            // set clock times here ...
            setTime(time);
        }

        // This is called by getMeteo once we receive API response,
        // where meteo is the complete JSON data.
        // See https://openweathermap.org/api/one-call-api#example for JSON structure
        function updateMeteo(meteo) {
            let hourWeather = getMeteoArray(meteo)


            moon_scaling(meteo["daily"][0]["moon_phase"])
        }


        // called by getMsg when we receive response
        function updateMsg(msgJSON) {
            // do stuff
        }

        //////////////////////////////////////////////////////////////////////


        // get Info //////////////////////////////////////////////////////////

        function getMeteo() {
            var url = "https://api.openweathermap.org/data/2.5/onecall?lat=45.5028" +
                "&lon=-73.608&units=metric&lang=en&appid=1eaf15e7cee034f3f9e265ccb4b57d4e"

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    var meteo = JSON.parse(this.responseText);

                    updateMeteo(meteo);
                }
            };
            req.open("GET", url, true);
            req.send();
        }


        function getTime() {
            var now = new Date();

            // This would probably go in the display function
            var listeMois = ["janvier", "février", "mars", "avril", "mai", "juin",
                "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

            let time = {
                "an": now.getFullYear(),
                "mois": now.getMonth(),
                "jour": now.getDate(),

                "h": now.getHours(),
                "m": now.getMinutes(),
                "s": now.getSeconds()
            }

            // 'testing'
            for (const [key, value] of Object.entries(time)) {
                document.getElementById("x-" + key).innerHTML = value;
            }

            return time
        }


        // return an array indicating the predictions by hours starting at 0h to 23h
        // Possible values in the returned array: https://openweathermap.org/weather-conditions#Weather-Condition-Codes-2
        //      - Clouds
        //      -
        //
        //  Should we check the precise description..?
        function getMeteoArray(meteoJSON) {
            let weather = [];

            let hourly = meteoJSON["hourly"];

            for (let h=0; h<24; ++h) {
                weather.push(hourly[h]["weather"][0]["main"])
            }

            return weather

        }


        function getMsg() {
            var url = "http://www.iro.umontreal.ca/~roys/ift1005/calendrier/test.php?" +
                "cal=now%2C%2B30sec%2Cbonjour%0D%0A%2B2min%2C%2B5min%2Csalut%2C%21%0D%0A%2B1hour%2C%2B30sec%2Callo%0D%0A"

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    var messages = JSON.parse(this.responseText);

                    updateMsg(messages);
                }
            };
            req.open("GET", url, true);
            req.send();
        }

        //////////////////////////////////////////////////////////////////////


        // DOM / micro updaters //////////////////////////////////////////////

        // Il serait peut etre mieux de faire un seul dessin de lune qui s'ajuste ...
        // We could also just set the moon phase to it's closest phase instead of
        //      making 8 presets... but it's inaccurate
        function moon_phase_name(moonPhase) { //Savoir le nom ne sera peut-être pas nécessaire au final
            var moon_name;
            const tolerance = 1;
            if (moonPhase === 0 || moonPhase === 1) {
                moon_name = 'new moon';
            } else if (moonPhase <= 0.25 + tolerance && moonPhase >= 0.25-tolerance) {
                moon_name = 'first quarter moon';
            } else if (moonPhase <= 0.50 + tolerance && moonPhase >= 0.50-tolerance) {
                moon_name = 'full moon';
            } else if (moonPhase <= 0.75 + tolerance && moonPhase >= 0.75-tolerance) {
                moon_name = 'last quarter moon';
            } else if (moonPhase < 0.25) {
                moon_name = 'waxing crescent';
            } else if (moonPhase < 0.5) {
                moon_name = 'waxing gibous';
            } else if (moonPhase < 0.75) {
                moon_name = 'waning gibous';
            } else {
                moon_name = 'waning crescent';
            }

            // TODO: remove me
            document.getElementById("x-moon_name").innerHTML = moon_name;
            document.getElementById("x-moon_phase").innerHTML = moonPhase;
        }


        //Sets the scaling values to draw the correct moon phase
        function moon_scaling(moonPhase){
            moonPhase = Math.abs(moonPhase) % 1;

            const root = document.querySelector(':root');
            var half_moon_right_scale;
            var half_moon_left_scale;
            var hider_scale;

            if (moonPhase < 0.25) {
                half_moon_right_scale = 1
                half_moon_left_scale = 0;
                hider_scale = 1-4*moonPhase;
            }
            else if (moonPhase < 0.5){
                half_moon_right_scale = 1
                half_moon_left_scale = 1-4*moonPhase;
                hider_scale = 0
            }
            else if (moonPhase < 0.75){
                half_moon_right_scale = 3-4*moonPhase;
                half_moon_left_scale = -1
                hider_scale = 0
            }
            else {
                half_moon_right_scale = 0
                half_moon_left_scale = -1
                hider_scale = 3-4*moonPhase;
            }
            root.style.setProperty('--half-moon-right-scale', half_moon_right_scale);
            root.style.setProperty('--half-moon-left-scale', half_moon_left_scale);
            root.style.setProperty('--hider-scale', hider_scale);

            //For debugging, may be deleted
            // console.log("half_moon_right_scale value is: " + half_moon_right_scale);
            // console.log("half_moon_left_scale value is: " + half_moon_left_scale);
            // console.log("hider_scale value is: " + hider_scale);

            moon_phase_name(moonPhase);
        }


        function setTime(time) {
            let all = [
                {"name": "h", "max": 23},
                {"name": "m", "max": 59},
                {"name": "s", "max": 59}
            ]

            for (let t of all) {
                let current = time[t["name"]];
                let prev = getPrevious(current, t["max"]);

                document.getElementById(t["name"] + "_" + prev).setAttribute("style", "animation: none");
                document.getElementById(t["name"] + "_" + current).setAttribute("style", "animation: glowBlue 1s linear infinite");
            }
        }

        //////////////////////////////////////////////////////////////////////


        // SVG Generation ////////////////////////////////////////////////////

        function finishSun() {
            let sun = document.getElementById("p_sun");
            const r = Number(sun.firstElementChild.getAttribute("r"));
            const cx = Number(sun.firstElementChild.getAttribute("cx"));
            const cy = Number(sun.firstElementChild.getAttribute("cy"));

            const spikeCount = 32;
            const increment = 2 * Math.PI / spikeCount;

            for (let i = 0; i < spikeCount; i++) {

                let theta1 = i * increment;
                let thetaMid = (i + 0.5) * increment; // adding above 1 makes it spiral
                let theta2 = (i + 1) * increment;

                let growth = 2;
                if (i % 2 !== 0) {
                    growth = 1.6
                }

                let points = [
                    polarPoint(cx, cy, 0.99 * r, theta1),
                    polarPoint(cx, cy, r * growth, thetaMid),
                    polarPoint(cx, cy, 0.99 * r, theta2)
                ];

                growSVG("p_sun", "polygon", {"points": pointsToAttr(points)})
            }
        }


        function makeClock() {
            genCadran(24, 500, 500, 400, 50, "h", "time")
            genCadran(60, 500, 500, 370, 30, "m", "time")
            genCadran(60, 500, 500, 350, 20, "s", "time", false) // Not sure if I like having the seconds in text
        }


        // TODO: document this,
        // We might want to split this up since this is very specific for
        // making the hours and minutes cells... <br>
        // maxVal is the number of cells (24 for hours...) <br>
        // <pre>
        // idBase specifies what id/class name the elements should have:
        //      cell:   id = [idBase]_[i]  for i in [0, 1, 2 ... maxVal]
        //              class = [className]_cell
        //      txt:    class1 = [idBase]_txt
        //              class2 = [className]_txt
        function genCadran(maxVal, cx, cy, r, dr, idBase, className, addText=true) {
            let theta = Math.PI / 2
            let increment = 2 * Math.PI / maxVal

            for (let i = 0; i < maxVal; i++) {
                let start = theta - i*increment;

                let path = polarRect(cx, cy, r, dr, start, -increment);

                growSVG("horloge", "path",
                    {
                        "d": path,
                        "id": idBase + "_" + i,
                        "class": className + "_" + "cell"
                    }
                );

                if (addText) {
                    let center = polarPoint(cx, cy, r + dr / 2, start - increment / 2)
                    let elem = growSVG("horloge", "text",
                        {
                            "x": center[0],
                            "y": center[1],
                            "class": idBase + "_" + "txt" + " " + className + "_" + "txt"
                        }
                    );
                    elem.innerHTML = i;
                }
            }
        }



        //////////////////////////////////////////////////////////////////////


        // Utils /////////////////////////////////////////////////////////////


        // We may prefer to compare epoch times directly
        function timeFromEpoch(seconds) {
            let date = new Date(seconds * 1000)
            return {
                "h": date.getHours(),
                "m": date.getMinutes(),
                "s": date.getSeconds()
            }
        }


        function getEpoch() {
            return Date.now()/1000
        }


        // Used to get previous hour / minute / second
        function getPrevious (value, maxVal) {
            if (value === 0) {
                return maxVal;
            }
            return value - 1;
        }

        // return a [x, y] point, <br>
        // allows to use angles as if we were using a right-handed coordinate
        // system with the svg left-handed system <br>
        // Theta should be given in radians
        function polarPoint(cx, cy, r, theta) {
            let y = cy - r * Math.sin(theta);
            let x = cx + r * Math.cos(theta);
            return [x, y];
        }


        // Return a string of path data for a polar rectangle <br>
        // cx, cy are center coords  <br>
        // r is the radius of the inner border dr is the 'depth' <br>
        // theta is the initial angle, <br>
        // See polarPoint info, angles work as in right-handed coords
        //
        // Does NOT work for dTheta > 180 (takes small arc)
        function polarRect(cx, cy, r, dr, theta, dTheta) {
            let rotX = 0;
            let largeArc = 0;
            let posSweep = 1;
            let negSweep = 0;

            let points = [
                polarPoint(cx, cy, r, theta),
                polarPoint(cx, cy, r + dr, theta),
                polarPoint(cx, cy, r + dr, theta + dTheta),
                polarPoint(cx, cy, r, theta + dTheta)
            ];

            return ["M ", points[0][0], points[0][1]].join(" ")
                 + [" L ", points[1][0], points[1][1]].join(" ")
                 + [" A ", r+dr, r+dr, rotX, largeArc, posSweep, points[2][0], points[2][1]].join(" ")
                 + [" L ", points[3][0], points[3][1]].join(" ")
                 + [" A ", r, r, rotX, largeArc, negSweep, points[0][0], points[0][1]].join(" ");

        }

        function testPolarRect() {
            for (let r=250; r > 5; r -= 20) {
                const nRects = 6;
                const increment = 2 * Math.PI / nRects;

                for (let i = 0; i < nRects; i++) {
                    if ( i % 2 === 0) {
                        growSVG("horloge", "path",
                            {
                                "d": polarRect(300, 400, r, 10, i * increment, increment),
                                "fill": "black"
                            }
                            );
                    }
                }
            }
        }




        // take a [x, y] point and return as "x,y"
        function pointToAttr(point) {
            return point[0] + "," + point[1];
        }

        // take and array of points [[x, y] ... ] <br>
        // and as "x,y x2,y2 ..."  (use to set attributes)
        function pointsToAttr(points) {
            let txt = "";
            for (point of points) {
                txt += pointToAttr(point) + " ";
            }
            return txt.slice(0, -1);
        }


        // Add a child element to another svg element and set attributes <br>
        // id is the id of the parent element to be grown <br>
        // tagName is the name of the SVG 'balise' (ex: circle, polygon...) <br>
        // <pre>
        // attributes is an object = {
        //                              "attributeName": "attributeValue"
        //                              ... }
        //
        // see finishSun() for example of use
        // Returns a reference to the newly created element
        function growSVG(id, tagName, attributes) {
            let elem = document.getElementById(id);
            let newItem = document.createElementNS(
                "http://www.w3.org/2000/svg", tagName);

            for (const [key, value] of Object.entries(attributes)) {
                newItem.setAttribute(key, value);
            }

            elem.appendChild(newItem);
            return newItem;
        }


        //////////////////////////////////////////////////////////////////////

    </script>


</head>


<body>

<svg id="p_draw" width="0" height="0" viewbox="0 0 100 100">

    <!-- Our primitives here! I encourage the use of the p_ prefix on primitives' ids
    Use a translate to center them around (0, 0) to make scaling/centering easier
     This means that all of or primitives **will be placed by their CENTER position** -->

    <defs>
        <!-- We use this svg space to draw our primitives.
             It also allows predictable behavior of gradients when using userSpaceOnUse (see below) -->

        <!-- userSpaceOnUse allows for the gradient to spread on groups
         (instead of applying to each element) Since it applies to global viewBox space -->
        <!-- Use CSS gradients to get support in FireFox -->
        <radialGradient id="sunGrad" cx="50" cy="50" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="yellow"/>
            <stop offset="100%" stop-color="orange"/>  <!-- Black for testing/example -->
        </radialGradient>

    </defs>

    <g id="p_sun" transform="translate(-50 -50)" fill="url('#sunGrad')">
        <circle r="25" cx="50" cy="50"/>
        <!-- JavaScript completes this -->
    </g>
</svg>

<svg width="0" height="0" viewbox="50 50 150 150">
    <!-- Moon phases -->
    <style>
        :root {
            --half-moon-right-scale: 0;
            --half-moon-left-scale: 0;
            --hider-scale: 0;
        }

        .half_circle{
            transform-origin: 100px;
        }
        .moon {
            fill: white;
        }
        .moon_hider {
            fill: black;
        }

        #half_moon_right {
            transform: scaleX( var(--half-moon-right-scale) );
        }
        #half_moon_left{
            transform: scaleX( var(--half-moon-left-scale) );
        }
        #hider {
            transform: scaleX( var(--hider-scale) );
        }

    </style>

    <defs>
        <g id="half_circle" class="half_circle">
            <clipPath id="clipRight">
                <rect x="100" y="50" width="100" height="100"/>
            </clipPath>
            <circle cx="100" cy="100" r="50" clip-path="url(#clipRight)"/>
        </g>

        <filter id="moonSurface" filterUnits="userSpaceOnUse">
            <feTurbulence baseFrequency="0.1" type="fractalNoise" numOctaves="1" seed="4"/>
            <feComposite operator="in" in="SourceGraphic"/>
        </filter>
    </defs>


    <g id="moon" transform="translate(-100 -100)">
        <circle id="fond" cx="100" cy="100" r="52" fill="black" stroke="gray" stroke-width="3" />

        <g id="moon_mask">
                <use href="#half_circle" id="half_moon_right" class="half_circle moon"/>
                <use href="#half_circle" id="half_moon_left" class="half_circle moon" />
        </g>

        <g>
        <circle id="fond" cx="100" cy="100" r="52"
                filter="url(#moonSurface)" stroke-width="3" />
        </g>
        <use href="#half_circle" id="hider" class="half_circle moon_hider"
             stroke="black" stroke-width="1" />
    </g>
</svg>



<svg id="horloge" width="100%" height="100%" viewBox="0 0 1000 1000">

    <style>

        /* TODO: find a way to make sure text always fit in the cells !important */
            /* It seems to scale correctly ... */

        /* For placing text by its center see the resources linked in:
                https://stackoverflow.com/a/31522006  */
        .time_txt {
            dominant-baseline: middle;
            text-anchor: middle;
            font-weight: bold;
        }

        .h_txt {
            font-size:2em;
        }

        .m_txt {
            font-size: 1.2em;
        }

        .s_txt {
            font-size: 1em;
        }

        .time_cell {
            fill: gray;
            stroke: black;
            stroke-width: 2px;
        }


        @keyframes glowBlue {
            0% { fill: aqua }
            50% { fill: rgb(0, 200, 200) } /* Darker */
            100% { fill: aqua }
        }

        .inMessageWindow {
            clip-path: url(#messageWindowClip);
        }


    </style>


    <defs>

        <!-- example of use -->
        <!-- Need to create a scaled instance before setting a position ... (If I need to scale that is)-->
        <use xlink:href="#p_sun" transform="scale(2)" id="big_sun"/>



    </defs>

    <!-- Canvas Box -->
<!--    <rect x="1" y="0" width="198" height="200" fill="none" stroke="black" stroke-width="1"/>-->


    <!-- Finally, I can position correctly with it's center -->
<!--    <use href="#big_sun" x="100" y="100"/>-->

    <circle cx="500" cy="500" r="400" fill="black"/>

    <use href="#moon" x="500" y="750"/>

    <rect id="messageWindow" x="350" y="400" width="300" height="200" rx="25" fill="aqua" style="animation: glowBlue 4s ease infinite" /> 
    <clipPath id="messageWindowClip">
        <use href="#messageWindow" /> 
    </clipPath>
    <!-- Was used to test clip: <rect x="300" y="475" width="200" height="150" rx="25" fill="green" class="inMessageWindow"  /> -->


</svg>


<ul>
    <li>L´année: <span id="x-an"></span></li>
    <li>Mois: <span id="x-mois"></span></li>
    <li>Jour: <span id="x-jour"></span></li>
    <li>Heure: <span id="x-h"></span></li>
    <li>Minute: <span id="x-m"></span></li>
    <li>Seconde: <span id="x-s"></span></li>
</ul>

<ul>
    <li>Phase de la lune: <span id="x-moon_phase"></span></li>
    <li>Nom de la phase: <span id="x-moon_name"></span></li>
</ul>

</body>

</html>

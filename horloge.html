<!DOCTYPE html>

<!--
    Nom                     |    id ssh     |       matricule   |
----------------------------------------------------------------|
Matthieu Beauchamp-Boulay   |   beaumatt    |       20234205    |
Zacharie Martel             |   martelza    |       20231059    |
Lien Miro:  https://miro.com/app/board/uXjVO9MT7jA=/
-->

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Horloge</title>

    <!-- Define our functions here -->
    <!-- getTime() void function, changes time in html document -->
    <script>
        window.onload = init;


        // Initializers //////////////////////////////////////////////////////

        function init() {
            initPrimitives();

            // testPolarRect()
            // TODO move this out
            genCadran(24, 500, 500, 400, 50, "h", "time")
            genCadran(60, 500, 500, 370, 30, "m", "time")
            genCadran(60, 500, 500, 350, 20, "s", "time", true) // Not sure I like having the seconds in text


            updateTime();
            getMeteo();

            setInterval(updateTime, 1000); // every second
            setInterval(getMeteo, 60000); // every minute
        }

        function initPrimitives() {
            finishSun();
        }

        //////////////////////////////////////////////////////////////////////


        // Updaters (macro) //////////////////////////////////////////////////

        function updateTime() {
            let time = getTime()

            // set clock times here ...
            setTime(time);
        }

        // This is called by getMeteo once we receive API response,
        // where meteo is the complete JSON data.
        // See https://openweathermap.org/api/one-call-api#example for JSON structure
        function updateMeteo(meteo) {

            moon_phase(meteo["daily"][0]["moon_phase"])
        }

        //////////////////////////////////////////////////////////////////////


        // get Info //////////////////////////////////////////////////////////

        function getMeteo() {
            var url = "https://api.openweathermap.org/data/2.5/onecall?lat=45.5028" +
                "&lon=-73.608&units=metric&lang=fr&appid=4ea015650a69d241ca53c20cda9f14ea"

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    var meteo = JSON.parse(this.responseText);

                    updateMeteo(meteo);
                }
            };
            req.open("GET", url, true);
            req.send();
        }

        function getTime() {
            var now = new Date();

            // This would probably go in the display function
            var listeMois = ["janvier", "février", "mars", "avril", "mai", "juin",
                "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

            let time = {
                "an": now.getFullYear(),
                "mois": now.getMonth(),
                "jour": now.getDate(),

                "h": now.getHours(),
                "m": now.getMinutes(),
                "s": now.getSeconds()
            }

            // 'testing'
            for (const [key, value] of Object.entries(time)) {
                document.getElementById("x-" + key).innerHTML = value;
            }

            return time
        }

        //////////////////////////////////////////////////////////////////////


        // DOM / micro updaters //////////////////////////////////////////////

        // Il serait peut etre mieux de faire un seul dessin de lune qui s'ajuste ...
        // We could also just set the moon phase to it's closest phase instead of
        //      making 8 presets... but it's inaccurate
        function moon_phase(moonPhase) {
            var moon_name;

            if (moonPhase === 0 || moonPhase === 1) {
                moon_name = 'new moon';
            } else if (moonPhase == 0.25) {
                moon_name = 'first quarter moon';
            } else if (moonPhase == 0.5) {
                moon_name = 'full moon';
            } else if (moonPhase == 0.75) {
                moon_name = 'last quarter moon';
            } else if (moonPhase < 0.25) {
                moon_name = 'waxing crescent';
            } else if (moonPhase < 0.5) {
                moon_name = 'waxing gibous';
            } else if (moonPhase < 0.75) {
                moon_name = 'waning gibous';
            } else {
                moon_name = 'waning crescent';
            }

            // TODO: remove me
            document.getElementById("x-moon_name").innerHTML = moon_name;
            document.getElementById("x-moon_phase").innerHTML = moonPhase;

        }


        function setTime(time) {
            let all = [
                {"name": "h", "max": 23},
                {"name": "m", "max": 59},
                {"name": "s", "max": 59}
            ]

            for (let t of all) {
                let current = time[t["name"]];
                let prev = getPrevious(current, t["max"]);

                document.getElementById(t["name"] + "_" + prev).setAttribute("style", "animation: none");
                document.getElementById(t["name"] + "_" + current).setAttribute("style", "animation: glowBlue 1s linear infinite");
            }
        }

        //////////////////////////////////////////////////////////////////////


        // SVG Generation ////////////////////////////////////////////////////

        function finishSun() {
            let sun = document.getElementById("p_sun");
            const r = Number(sun.firstElementChild.getAttribute("r"));
            const cx = Number(sun.firstElementChild.getAttribute("cx"));
            const cy = Number(sun.firstElementChild.getAttribute("cy"));

            const spikeCount = 32;
            const increment = 2 * Math.PI / spikeCount;

            for (let i = 0; i < spikeCount; i++) {

                let theta1 = i * increment;
                let thetaMid = (i + 0.5) * increment; // adding above 1 makes it spiral
                let theta2 = (i + 1) * increment;

                let growth = 2;
                if (i % 2 !== 0) {
                    growth = 1.6
                }

                let points = [
                    polarPoint(cx, cy, 0.99 * r, theta1),
                    polarPoint(cx, cy, r * growth, thetaMid),
                    polarPoint(cx, cy, 0.99 * r, theta2)
                ];

                growSVG("p_sun", "polygon", {"points": pointsToAttr(points)})
            }
        }


        // TODO: document this,
        // We might want to split this up since this is very specific for
        // making the hours and minutes cells... <br>
        // maxVal is the number of cells (24 for hours...) <br>
        // <pre>
        // idBase specifies what id/class name the elements should have:
        //      cell:   id = [idBase]_[i]  for i in [0, 1, 2 ... maxVal]
        //              class = [className]_cell
        //      txt:    class1 = [idBase]_txt
        //              class2 = [className]_txt
        function genCadran(maxVal, cx, cy, r, dr, idBase, className, addText=true) {
            let theta = Math.PI / 2
            let increment = 2 * Math.PI / maxVal

            for (let i = 0; i < maxVal; i++) {
                let start = theta - i*increment;

                let path = polarRect(cx, cy, r, dr, start, -increment);

                growSVG("horloge", "path",
                    {
                        "d": path,
                        "id": idBase + "_" + i,
                        "class": className + "_" + "cell"
                    }
                );

                if (addText) {
                    let center = polarPoint(cx, cy, r + dr / 2, start - increment / 2)
                    let elem = growSVG("horloge", "text",
                        {
                            "x": center[0],
                            "y": center[1],
                            "class": idBase + "_" + "txt" + " " + className + "_" + "txt"
                        }
                    );
                    elem.innerHTML = i;
                }
            }
        }




        //////////////////////////////////////////////////////////////////////


        // Utils /////////////////////////////////////////////////////////////

        function getPrevious (value, maxVal) {
            if (value === 0) {
                return maxVal;
            }
            return value - 1;
        }

        // return a [x, y] point, <br>
        // allows to use angles as if we were using a right-handed coordinate
        // system with the svg left-handed system <br>
        // Theta should be given in radians
        function polarPoint(cx, cy, r, theta) {
            let y = cy - r * Math.sin(theta);
            let x = cx + r * Math.cos(theta);
            return [x, y];
        }


        // Return a string of path data for a polar rectangle <br>
        // cx, cy are center coords  <br>
        // r is the radius of the inner border dr is the 'depth' <br>
        // theta is the initial angle, <br>
        // See polarPoint info, angles work as in right-handed coords
        //
        // Does NOT work for dTheta > 180 (takes small arc)
        function polarRect(cx, cy, r, dr, theta, dTheta) {
            let rotX = 0;
            let largeArc = 0;
            let posSweep = 1;
            let negSweep = 0;

            let points = [
                polarPoint(cx, cy, r, theta),
                polarPoint(cx, cy, r + dr, theta),
                polarPoint(cx, cy, r + dr, theta + dTheta),
                polarPoint(cx, cy, r, theta + dTheta)
            ];

            return ["M ", points[0][0], points[0][1]].join(" ")
                 + [" L ", points[1][0], points[1][1]].join(" ")
                 + [" A ", r+dr, r+dr, rotX, largeArc, posSweep, points[2][0], points[2][1]].join(" ")
                 + [" L ", points[3][0], points[3][1]].join(" ")
                 + [" A ", r, r, rotX, largeArc, negSweep, points[0][0], points[0][1]].join(" ");

        }

        function testPolarRect() {
            for (let r=250; r > 5; r -= 20) {
                const nRects = 6;
                const increment = 2 * Math.PI / nRects;

                for (let i = 0; i < nRects; i++) {
                    if ( i % 2 === 0) {
                        growSVG("horloge", "path",
                            {
                                "d": polarRect(300, 400, r, 10, i * increment, increment),
                                "fill": "black"
                            }
                            );
                    }
                }
            }
        }


        // take a [x, y] point and return as "x,y"
        function pointToAttr(point) {
            return point[0] + "," + point[1];
        }

        // take and array of points [[x, y] ... ] <br>
        // and as "x,y x2,y2 ..."  (use to set attributes)
        function pointsToAttr(points) {
            let txt = "";
            for (point of points) {
                txt += pointToAttr(point) + " ";
            }
            return txt.slice(0, -1);
        }


        // Add a child element to another svg element and set attributes <br>
        // id is the id of the parent element to be grown <br>
        // tagName is the name of the SVG 'balise' (ex: circle, polygon...) <br>
        // <pre>
        // attributes is an object = {
        //                              "attributeName": "attributeValue"
        //                              ... }
        //
        // see finishSun() for example of use
        // Returns a reference to the newly created element
        function growSVG(id, tagName, attributes) {
            let elem = document.getElementById(id);
            let newItem = document.createElementNS(
                "http://www.w3.org/2000/svg", tagName);

            for (const [key, value] of Object.entries(attributes)) {
                newItem.setAttribute(key, value);
            }

            elem.appendChild(newItem);
            return newItem;
        }


        //////////////////////////////////////////////////////////////////////

    </script>


</head>


<body>

<svg id="p_draw" width="0" height="0" viewbox="0 0 100 100">

    <!-- Our primitives here! I encourage the use of the p_ prefix on primitives' ids
    Use a translate to center them around (0, 0) to make scaling/centering easier
     This means that all of or primitives **will be placed by their CENTER position** -->

    <defs>
        <!-- We use this svg space to draw our primitives.
             It also allows predictable behavior of gradients when using userSpaceOnUse (see below) -->

        <!-- userSpaceOnUse allows for the gradient to spread on groups
         (instead of applying to each element) Since it applies to global viewBox space -->
        <!--Inconsistent behavior between Firefox and chrome when not specifying cx, cy...-->
        <radialGradient id="sunGrad" cx="50" cy="50" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="yellow"/>
            <stop offset="100%" stop-color="orange"/>  <!-- Black for testing/example -->
        </radialGradient>

        <g id="p_sun" transform="translate(-50 -50)" fill="url('#sunGrad')">
            <circle r="25" cx="50" cy="50"/>
            <!-- JavaScript completes this -->
        </g>

    </defs>


</svg>


<svg id="horloge" width="100%" height="100%" viewBox="0 0 1000 1000">

    <style>

        /* TODO: find a way to make sure text always fit in the cells !important */
            /* It seems to scale correctly ... */

        /* For placing text by its center see the resources linked in:
                https://stackoverflow.com/a/31522006  */
        .time_txt {
            dominant-baseline: middle;
            text-anchor: middle;
            font-weight: bold;
        }

        .h_txt {
            font-size:2em;
        }

        .m_txt {
            font-size: 1.2em;
        }

        .s_txt {
            font-size: 1em;
        }

        .time_cell {
            fill: lightgrey;
            stroke: black;
            stroke-width: 2px;
        }


        @keyframes glowBlue {
            0% { fill: aqua }
            50% { fill: rgb(0, 200, 200) } /* Darker */
            100% { fill: aqua }
        }


    </style>


    <defs>

        <!-- example of use -->
        <!-- Need to create a scaled instance before setting a position ... (If I need to scale that is)-->
        <use xlink:href="#p_sun" transform="scale(2)" id="big_sun"/>

    </defs>

    <!-- Canvas Box -->
    <rect x="1" y="0" width="198" height="200" fill="none" stroke="black" stroke-width="1"/>


    <!-- Finally, I can position correctly with it's center -->
    <use href="#big_sun" x="100" y="100"/>


</svg>

<ul>
    <li>L´année: <span id="x-an"></span></li>
    <li>Mois: <span id="x-mois"></span></li>
    <li>Jour: <span id="x-jour"></span></li>
    <li>Heure: <span id="x-h"></span></li>
    <li>Minute: <span id="x-m"></span></li>
    <li>Seconde: <span id="x-s"></span></li>
</ul>

<ul>
    <li>Phase de la lune: <span id="x-moon_phase"></span></li>
    <li>Nom de la phase: <span id="x-moon_name"></span></li>
</ul>

</body>

</html>

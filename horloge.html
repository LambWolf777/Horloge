<!DOCTYPE html>

<!--
    Nom                     |    id ssh     |       matricule   |
----------------------------------------------------------------|
Matthieu Beauchamp-Boulay   |   beaumatt    |       20234205    |
Zacharie Martel             |   martelza    |       20231059    |
Ã‰mile-Jacob Le Blanc        |   leblanej    |       20188645    |

Lien Miro:  https://miro.com/app/board/uXjVO9MT7jA=/
-->

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Horloge</title>

    <!-- Define our functions here -->
    <!-- getTime() void function, changes time in html document -->
    <script>
        window.onload = init;

        // Initializers //////////////////////////////////////////////////////

        function init() {
            initPrimitives();

            makeClock();    // makes the hours/minutes/seconds

            updateTime();
            getMeteo();
            getMsg();

            let i = 0
            setInterval(function () {
                i++;
                moon_scaling(i / 1000);
            }, 10);


            setInterval(updateTime, 100);                               // every millisecond
            setInterval(function () { updateMsg(messages); }, 1000);    // every second
            setInterval(getMeteo, 1000 * 60 * 60);                      // every hour
        }

        function initPrimitives() {
            finishSun();
            finishDroplet();
        }

        //////////////////////////////////////////////////////////////////////


        // Updaters (macro) //////////////////////////////////////////////////

        function updateTime() {
            let time = getTime();

            // set clock times here ...
            setTime(time);

            animateSun(time);
        }

        // This is called by getMeteo once we receive API response,
        // where meteo is the complete JSON data.
        // See https://openweathermap.org/api/one-call-api#example for JSON structure
        function updateMeteo(meteo) {
            let hourWeather = getMeteoArray(meteo);

            setMeteo(hourWeather)
            setSun_R_S(meteo);

            moon_scaling(meteo["daily"][0]["moon_phase"]);
        }


        // called by getMsg when we receive response
        function updateMsg(msgJSON) {
            var currentEpoch = Math.round(Date.now() / 1000);
            const msgNode = document.getElementById("messageText");
            const animDuration = parseInt(window.getComputedStyle(msgNode).transitionDuration.slice(0, -1));

            for (var i = 0; i < msgJSON.length; i++) {
                var calEvent = msgJSON[i];
                calEvent["active"] = (calEvent.debut < currentEpoch && currentEpoch < calEvent.fin);
                if (calEvent["active"]) {
                    msg = calEvent.message;
                    msgNode.classList.add("active");
                    if (calEvent["important"]) {
                        msgNode.classList.add("importantMsg");
                    } else {
                        msgNode.classList.remove("importantMsg");
                    }
                    calEvent["lastActive"] = calEvent["active"];
                } else if (calEvent["lastActive"]) {
                    msgNode.classList.replace("active", "leaving");
                    setTimeout(function () {
                        msg = ""
                        msgNode.innerHTML = msg;
                        msgNode.classList.remove("leaving");
                    }, animDuration * 1000);

                }

                calEvent["lastActive"] = calEvent["active"];

            }
            msgNode.innerHTML = msg;
        }

        //////////////////////////////////////////////////////////////////////


        // get Info //////////////////////////////////////////////////////////


        // Get the meteo JSON and call to updateMeteo once we receive
        function getMeteo() {
            var url = "https://api.openweathermap.org/data/2.5/onecall?lat=45.5028" +
                "&lon=-73.608&units=metric&lang=en&appid=1eaf15e7cee034f3f9e265ccb4b57d4e";

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    var meteo = JSON.parse(this.responseText);

                    updateMeteo(meteo);
                }
            };
            req.open("GET", url, true);
            req.send();
        }


        // Returns an object containing various units to represent current time
        function getTime() {
            var now = new Date();

            return {
                "an": now.getFullYear(),
                "mois": now.getMonth(),
                "jour": now.getDate(),

                "h": now.getHours(),
                "m": now.getMinutes(),
                "s": now.getSeconds(),
                "ms": now.getMilliseconds()
            };
        }


        // return an array indicating the predictions by hours starting at 0h to 23h
        // Possible values in the returned array: https://openweathermap.org/weather-conditions#Weather-Condition-Codes-2
        //      - Clouds
        //      - Thunderstorm
        //      - Drizzle
        //      - Rain
        //      - Snow
        //      - Clear
        //      - *** Others, group 7xx ...? what should we do for these special cases
        //
        //  Should we check the precise description..?
        function getMeteoArray(meteoJSON) {
            let weather = [];

            let hourly = meteoJSON["hourly"];

            for (let h = 0; h < 24; ++h) {
                weather.push(hourly[h]["weather"][0]["main"]);
            }

            return weather;
        }


        // get sunrise and sunset as Date objects
        function getSun_R_S(meteoJSON) {
            let sunrise = meteoJSON["current"]["sunrise"];
            let sunset = meteoJSON["current"]["sunset"];

            return {
                "sunrise": timeFromEpoch(sunrise),
                "sunset": timeFromEpoch(sunset)
            };
        }


        // Get message JSON
        var messages;

        function getMsg() {
            var url = "http://www.iro.umontreal.ca/~roys/ift1005/calendrier/test.php?" +
                "cal=now%2C%2B30sec%2Cbonjour%0D%0A%2B2min%2C%2B5min%2Csalut%2C%21%0D%0A%2B1hour%2C%2B30sec%2Callo%0D%0A"

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    messages = JSON.parse(this.responseText);
                    //append new proprieties to each event for updateMeteo(messages)
                    for (var i = 0; i < messages.length; i++) {
                        messages[i]["active"] = false;
                        messages[i]["lastActive"] = false;
                    }
                }
            };
            req.open("GET", url, true);
            req.send();
        }


        //////////////////////////////////////////////////////////////////////


        // DOM / micro updaters //////////////////////////////////////////////


        //Sets the scaling values to draw the correct moon phase
        function moon_scaling(moonPhase) {
            moonPhase = Math.abs(moonPhase) % 1;

            const root = document.querySelector(':root');
            var half_moon_right_scale;
            var half_moon_left_scale;
            var hider_scale;

            if (moonPhase < 0.25) {
                half_moon_right_scale = 1;
                half_moon_left_scale = 0;
                hider_scale = 1 - 4 * moonPhase;
            } else if (moonPhase < 0.5) {
                half_moon_right_scale = 1;
                half_moon_left_scale = 1 - 4 * moonPhase;
                hider_scale = 0;
            } else if (moonPhase < 0.75) {
                half_moon_right_scale = 3 - 4 * moonPhase;
                half_moon_left_scale = -1;
                hider_scale = 0;
            } else {
                half_moon_right_scale = 0;
                half_moon_left_scale = -1;
                hider_scale = 3 - 4 * moonPhase;
            }
            root.style.setProperty('--half-moon-right-scale', half_moon_right_scale);
            root.style.setProperty('--half-moon-left-scale', half_moon_left_scale);
            root.style.setProperty('--hider-scale', hider_scale);

        }


        // Update the time shown on the clock by changing the animation attribute of
        // the previous and current time cells
        function setTime(time) {
            let all = [
                {"name": "h", "max": 23},
                {"name": "m", "max": 59},
                {"name": "s", "max": 59}
            ];

            for (let t of all) {
                let current = time[t["name"]];
                let prev = getPrevious(current, t["max"]);

                document.getElementById(t["name"] + "_" + prev)
                    .setAttribute("style", "animation: none");

                document.getElementById(t["name"] + "_" + current)
                    .setAttribute("style", "animation: glowBlue 1s linear infinite");
            }
        }


        // Change between displaying the hourly meteo predictions
        //      and the sunrise/sunset times
        var displayingWeather = true; //set false to display sunrise/sunset by default instead
        function switchDisplay() {

            displayingWeather = !displayingWeather;
            if (displayingWeather) {
                //make weather stuff 'display: none;'' or a fancier animation if we'd like
                //make sunrise stuff display

                document.getElementById("sun_R_S").setAttribute("display", "none");

            } else {
                //make sunset/sunrise stuff 'display: none;'' or a fancier animation if we'd like
                //make weather stuff display

                document.getElementById("sun_R_S").setAttribute("display", "default");

            }
        }


        // Creates a <g id="sun_R_S"> containing the necessary elements to show the hours
        // of sunrise and sunset outside the hours 'Cadrans'
        function setSun_R_S(meteoJSON) {
            let info = getSun_R_S(meteoJSON);

            let sunrise = info["sunrise"]["h"];
            let sunset = info["sunset"]["h"];

            let increment = -2 * Math.PI / 24;  // Move by one hour
            const topTheta = Math.PI / 2;  // Aligned on hour 0

            // Group
            growSVG("horloge", "g",
                {
                    "id": "sun_R_S",
                    "display": "none"   // Hidden on load
                }
            );

            // sunrise
            growSVG("sun_R_S", "path",
                {
                    "d": polarRect(500, 500, 400, 100, topTheta + sunrise * increment, increment),
                    "fill": "rgb(225,100,156)",
                    "stroke": "black",
                    "stroke-width": "2"
                }
            );

            let pointRise = polarPoint(500, 500, 450, topTheta + sunrise * increment + increment / 2)
            growSVG("sun_R_S", "use",
                {
                    "href": "#p_sun",
                    "x": pointRise[0],
                    "y": pointRise[1]
                }
            );


            // sunset
            growSVG("sun_R_S", "path",
                {
                    "d": polarRect(500, 500, 400, 100, topTheta + sunset * increment, increment),
                    "fill": "url(#starry)",
                    "stroke": "black",
                    "stroke-width": "2",
                }
            );

            let pointSet = polarPoint(500, 500, 450, topTheta + sunset * increment + increment / 2)
            growSVG("sun_R_S", "use",
                {
                    "href": "#sunset",
                    "x": pointSet[0],
                    "y": pointSet[1]
                }
            );
        }


        function setMeteo(meteoArray) {
            let currentHour = getTime()["h"];

            let increment = -2 * Math.PI / 24;  // Move by one hour
            const topTheta = Math.PI / 2;  // Aligned on hour 0

            let startTheta = topTheta + currentHour * increment;







        }

        //////////////////////////////////////////////////////////////////////


        // SVG Generation ////////////////////////////////////////////////////

        function finishSun(thetaOffset = 0) {
            let sun = document.getElementById("p_sun");
            const r = Number(sun.firstElementChild.getAttribute("r"));
            const cx = Number(sun.firstElementChild.getAttribute("cx"));
            const cy = Number(sun.firstElementChild.getAttribute("cy"));

            const spikeCount = 32;
            const increment = 2 * Math.PI / spikeCount;

            for (let i = 0; i < spikeCount; i++) {

                let theta1 = i * increment;
                let thetaMid = (i + 0.5 + thetaOffset) * increment; // adding above 1 makes it spiral
                let theta2 = (i + 1) * increment;

                let growth = 2;
                if (i % 2 !== 0) {
                    growth = 1.6;
                }

                let points = [
                    polarPoint(cx, cy, 0.99 * r, theta1),
                    polarPoint(cx, cy, r * growth, thetaMid),
                    polarPoint(cx, cy, 0.99 * r, theta2)
                ];

                growSVG("p_sun", "polygon", {"points": pointsToAttr(points)});
            }
        }


        function animateSun(time) {
            // Reset Sun
            document.getElementById("p_sun").innerHTML = "<circle r=\"24\" cx=\"50\" cy=\"50\"/>\n";

            const duration = 2000;  // ms
            let milliseconds = (time.s % 2) * 1000 + time.ms;

            const piFactor = 2 * Math.PI / duration;
            let thetaOffset = Math.sin(milliseconds * piFactor);

            finishSun(thetaOffset);
        }


        function finishDroplet() {
            let p = polarPoint(50, 70, 30, Math.PI / 6);

            growSVG("p_droplet",
                "path",
                {
                    "d": "M 50 100"
                        + arcPath(50, 70, 30, -7 * Math.PI / 6)
                        + " Q 50 20 50 0"

                        + " Q 50 20 " + p[0] + " " + p[1]
                        + arcPath(50, 70, 30, -Math.PI / 2),
                }
            );

            growSVG("p_droplet",
                "path",
                {
                    "d": polarRect(50, 70, 20, 5, Math.PI, -Math.PI / 6),
                    "fill": "white",
                    "opacity": 0.85
                }
            );
        }


        // Makes the hour, minutes and seconds "Cadrans"
        function makeClock() {
            genCadran(24, 500, 500, 350, 50, "h", "time");
            genCadran(60, 500, 500, 320, 30, "m", "time");
            genCadran(60, 500, 500, 300, 20, "s", "time", false); // Not sure if I like having the seconds in text
        }


        // TODO: document this,
        // We might want to split this up since this is very specific for
        // making the hours and minutes cells... <br>
        // maxVal is the number of cells (24 for hours...) <br>
        // <pre>
        // idBase specifies what id/class name the elements should have:
        //      cell:   id = [idBase]_[i]  for i in [0, 1, 2 ... maxVal]
        //              class = [className]_cell
        //      txt:    class1 = [idBase]_txt
        //              class2 = [className]_txt
        function genCadran(maxVal, cx, cy, r, dr, idBase, className, addText = true) {
            let theta = Math.PI / 2;
            let increment = 2 * Math.PI / maxVal;

            for (let i = 0; i < maxVal; i++) {
                let start = theta - i * increment;

                let path = polarRect(cx, cy, r, dr, start, -increment);

                growSVG("horloge", "path",
                    {
                        "d": path,
                        "id": idBase + "_" + i,
                        "class": className + "_" + "cell"
                    }
                );

                if (addText) {
                    let center = polarPoint(cx, cy, r + dr / 2, start - increment / 2);
                    let elem = growSVG("horloge", "text",
                        {
                            "x": center[0],
                            "y": center[1],
                            "class": idBase + "_" + "txt" + " " + className + "_" + "txt"
                        }
                    );
                    elem.innerHTML = i;
                }
            }
        }


        //////////////////////////////////////////////////////////////////////


        // Utils /////////////////////////////////////////////////////////////


        // We may prefer to compare epoch times directly
        function timeFromEpoch(seconds) {
            let date = new Date(seconds * 1000);
            return {
                "h": date.getHours(),
                "m": date.getMinutes(),
                "s": date.getSeconds()
            };
        }


        // Used to get previous hour / minute / second
        function getPrevious(value, maxVal) {
            if (value === 0) {
                return maxVal;
            }
            return value - 1;
        }


        // return a [x, y] point, <br>
        // allows to use angles as if we were using a right-handed coordinate
        // system with the svg left-handed system <br>
        // Theta should be given in radians
        function polarPoint(cx, cy, r, theta) {
            let y = cy - r * Math.sin(theta);
            let x = cx + r * Math.cos(theta);
            return [x, y];
        }


        // Return a string of path data for a polar rectangle <br>
        // cx, cy are center coords  <br>
        // r is the radius of the inner border dr is the 'depth' <br>
        // theta is the initial angle, <br>
        // See polarPoint info, angles work as in right-handed coords
        //
        // Does NOT work for dTheta > 180 (takes small arc)
        function polarRect(cx, cy, r, dr, theta, dTheta) {
            let rotX = 0;
            let largeArc = 0;
            let posSweep = Number(dTheta < 0);
            let negSweep = Number(!posSweep);

            let points = [
                polarPoint(cx, cy, r, theta),
                polarPoint(cx, cy, r + dr, theta),
                polarPoint(cx, cy, r + dr, theta + dTheta),
                polarPoint(cx, cy, r, theta + dTheta)
            ];

            return ["M ", points[0][0], points[0][1]].join(" ")
                + [" L ", points[1][0], points[1][1]].join(" ")
                + [" A ", r + dr, r + dr, rotX, largeArc, posSweep, points[2][0], points[2][1]].join(" ")
                + [" L ", points[3][0], points[3][1]].join(" ")
                + [" A ", r, r, rotX, largeArc, negSweep, points[0][0], points[0][1]].join(" ");
        }


        // Return the path data for an arc, angles are in radians
        function arcPath(cx, cy, r, dTheta) {
            let rotX = 0;
            let largeArc = 0;
            let sweep = Number(dTheta < 0);

            let p2 = polarPoint(cx, cy, r, dTheta);

            return [" A", r, r, rotX, largeArc, sweep, p2[0], p2[1]].join(" ");
        }


        // take a [x, y] point and return as "x,y"
        function pointToAttr(point) {
            return point[0] + "," + point[1];
        }

        // take and array of points [[x, y] ... ] <br>
        // and as "x,y x2,y2 ..."  (use to set attributes)
        function pointsToAttr(points) {
            let txt = "";
            for (point of points) {
                txt += pointToAttr(point) + " ";
            }
            return txt.slice(0, -1);
        }


        // Add a child element to another svg element and set attributes <br>
        // id is the id of the parent element to be grown <br>
        // tagName is the name of the SVG 'balise' (ex: circle, polygon...) <br>
        // <pre>
        // attributes is an object = {
        //                              "attributeName": "attributeValue"
        //                              ... }
        //
        // see finishSun() for example of use
        // Returns a reference to the newly created element
        function growSVG(id, tagName, attributes) {
            let elem = document.getElementById(id);
            let newItem = document.createElementNS(
                "http://www.w3.org/2000/svg", tagName);

            for (const [key, value] of Object.entries(attributes)) {
                newItem.setAttribute(key, value);
            }

            elem.appendChild(newItem);
            return newItem;
        }


        //////////////////////////////////////////////////////////////////////

    </script>


</head>

<body>


<svg id="p_draw" width="0" height="0" viewbox="0 0 100 100">

    <!-- Our primitives here! I encourage the use of the p_ prefix on primitives' ids
    Use a translate to center them around (0, 0) to make scaling/centering easier
     This means that all of or primitives **will be placed by their CENTER position** -->

    <defs>
        <!-- We use this svg space to draw our primitives.
             It also allows predictable behavior of gradients when using userSpaceOnUse (see below) -->

        <!-- userSpaceOnUse allows for the gradient to spread on groups
         (instead of applying to each element) Since it applies to global viewBox space -->

        <!-- Use CSS gradients to get support in FireFox ... too bad-->
        <radialGradient id="sunGrad" cx="50" cy="50" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="yellow"/>
            <stop offset="100%" stop-color="orange"/>
        </radialGradient>

        <radialGradient id="starGrad" cx="50" cy="50" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="rgb(118, 230, 236)"/>
            <stop offset="100%" stop-color="white"/>
        </radialGradient>

    </defs>

    <g id="p_sun" transform="translate(-50 -50)" fill="url('#sunGrad')">
        <circle r="24" cx="50" cy="50"/>
        <!-- JavaScript completes this -->
    </g>

    <g id="p_droplet" transform="translate(-50 -50)" fill="blue">
        <!-- Javascript generated -->
    </g>


    <g id="p_snowflake" transform="translate(-50 -50)" stroke="lightblue" stroke-width="2">
        <path d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="scale(1,-1) translate(0, -100)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(45, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(90, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(135, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(-45, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(-90, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
        <path transform="rotate(-135, 50, 50)"
              d="M 50 50 v -40 M 50 35 l -10 -10 M 50 35 l 10 -10 M 50 25 l -7 -7 M 50 25 l 7 -7"/>
    </g>


    <!-- cloud that takes the upper 40 units and 100 wide of a 100x100 draw box
         Positionned by the center of the 100x100 drawBox -->
    <g id="p_cloud" transform="translate(-50 -50)">
        <path stroke="black"
              d="M 45 40
              h 40
              a 14 14 1 0 0 0 -28
              a 20 14 1 0 0 -30 -7
              a 14 23 1 0 0 -16 7
              a 16 20 1 0 0 -16 7
              a 10 7 1 0 0 -13 20 Z"/>
    </g>

    <g id="p_lightning" transform="translate(-50 -50)">
        <path fill="yellow" stroke="black"
              d="M 50 0
                 L 65 50
                 L 35 60

                 L 40 100

                 L 15 50
                 L 45 40

                 L 30 0
                 Z"/>
    </g>


    <g id="p_star" transform="translate(-50 -50)" fill="url('#starGrad')">
        <path d="M 50 0
                 L 60 40
                 L 100 50
                 L 60 60
                 L 50 100
                 L 40 60
                 L 0 50
                 L 40 40
                 Z"/>
    </g>

</svg>


<!-- Moon Drawbox -->
<svg width="0" height="0" viewbox="50 50 150 150">
    <style>
        :root {
            --half-moon-right-scale: 0;
            --half-moon-left-scale: 0;
            --hider-scale: 0;
        }

        .half_circle {
            transform-origin: 100px;
        }

        .moon {
            fill: white;
        }

        .moon_hider {
            fill: black;
        }

        #half_moon_right {
            transform: scaleX(var(--half-moon-right-scale));
        }

        #half_moon_left {
            transform: scaleX(var(--half-moon-left-scale));
        }

        #hider {
            transform: scaleX(var(--hider-scale));
        }

    </style>

    <defs>
        <g id="half_circle" class="half_circle">
            <clipPath id="clipRight">
                <rect x="100" y="50" width="100" height="100"/>
            </clipPath>
            <circle cx="100" cy="100" r="50" clip-path="url(#clipRight)"/>
        </g>

        <filter id="moonSurface" filterUnits="userSpaceOnUse">
            <feTurbulence baseFrequency="0.1" type="fractalNoise" numOctaves="1" seed="4"/>
            <feComposite operator="in" in="SourceGraphic"/>
        </filter>
    </defs>


    <g id="moon" transform="translate(-100 -100)">
        <circle id="fond" cx="100" cy="100" r="52" fill="black" stroke="gray" stroke-width="3"/>

        <g id="moon_mask">
            <use href="#half_circle" id="half_moon_right" class="half_circle moon"/>
            <use href="#half_circle" id="half_moon_left" class="half_circle moon"/>
        </g>

        <g>
            <circle id="fond" cx="100" cy="100" r="52"
                    filter="url(#moonSurface)" stroke-width="3"/>
        </g>
        <use href="#half_circle" id="hider" class="half_circle moon_hider"
             stroke="black" stroke-width="1"/>
    </g>
</svg>


<svg id="horloge" width="min(100vw, 100vh)" height="min(100vw, 100vh)" viewBox="0 0 1000 1000">

    <style>

        /* For placing text by its center see the resources linked in:
                https://stackoverflow.com/a/31522006  */
        .time_txt {
            dominant-baseline: middle;
            text-anchor: middle;
            font-weight: bold;
        }

        .h_txt {
            font-size: 2em;
        }

        .m_txt {
            font-size: 1.2em;
        }

        .s_txt {
            font-size: 1em;
        }

        .time_cell {
            fill: gray;
            stroke: black;
            stroke-width: 2px;
        }


        @keyframes glowBlue {
            0% {
                fill: aqua
            }
            50% {
                fill: rgb(0, 200, 200)
            }
            /* Darker */
            100% {
                fill: aqua
            }
        }

        @keyframes swaying {
            from {
                transform: translateX(-10px);
            }
            to {
                transform: translate(10px);
            }
        }


        #button {
            fill: red;
        }

        #button:active {
            fill: rgb(119, 0, 0);
        }

        #windowMask {
            mask-type: luminance;
        }

        #messageText {
            fill: black;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 60px;
            transition-property: transform;
            transition-duration: 1s;
            text-anchor: middle;

        }

        #messageText.active {
            transform: translateY(135px);
        }

        #messageText.leaving {
            transform: translateY(270px);
        }

        #messageText.importantMsg {
            /* more styling could be applied to important messages
            (fill, animation...) */
            font-weight: bolder;
        }

    </style>


    <defs>

        <!-- Adapted drawables -->
        <use id="drop" href="#p_droplet" transform="scale(0.3)"/>
        <use id="smallDrop" href="#p_droplet" transform="scale(0.15)"/>
        <use id="snowflake" href="#p_snowflake" transform="scale(0.3)"/>

        <use id="smallStar" href="#p_star" transform="scale(0.08)">
            <animateTransform
                    attributeName="transform"
                    attributeType="XML"
                    type="scale"
                    values="0.08; 0.1; 0.08"
                    dur="1s"
                    calcMode="linear"
                    repeatCount="indefinite"/>
        </use>

        <use id="smallMoon" href="#moon" transform="scale(0.5)"/>
        <g id="sunset" transform="translate(-50 -50)">
            <use href="#smallMoon" x="50" y="50"/>
        </g>

        <pattern id="starry" viewBox="0 0 12 12" width="10%" height="10%">
            <rect x="0" y="0" width="12" height="12" fill="rgba(22,34,77,1)" stroke="rgba(22,34,77,1)"/>
            <use href="#smallStar" x="6" y="6"/>
        </pattern>

        <use id="darkCloud" href="#p_cloud" transform="scale(-0.8, 1)" fill="rgb(100, 100, 100)"/>
        <use id="lightCloud2" href="#p_cloud" transform="scale(-0.8, 1)" fill="lightgray"/>
        <use id="lightCloud" href="#p_cloud" transform="scale(0.8, 1)" fill="lightgray"/>

        <g id="rainClouds" transform="translate(-50 -50)">
            <use href="#lightCloud" x="60" y="50"/>
            <use href="#darkCloud" x="40" y="55"/>
        </g>

        <!-- Meteo prediction drawables should all fit in a 100x100 box and to be placed by their centers -->
        <g id="Clear">
            <use href="#p_sun"/>
        </g>

        <g id="Clouds" transform="translate(-50 -50)">
            <use href="#lightCloud" x="60" y="50"/>
            <use href="#lightCloud2" x="40" y="55"/>
        </g>

        <g id="Rain" transform="translate(-50 -50)">
            <use href="#drop" x="25" y="20">
                <animate attributeName="y" values="20;80" dur="1s" repeatCount="indefinite"/>
            </use>
            <use href="#drop" x="50" y="20">
                <animate attributeName="y" values="20;80" dur="0.85s" repeatCount="indefinite"/>
            </use>
            <use href="#drop" x="75" y="20">
                <animate attributeName="y" values="20;80" dur="0.75s" repeatCount="indefinite"/>
            </use>

            <use href="#rainClouds" x="50" y="50"/>
        </g>

        <g id="Drizzle" transform="translate(-50 -50)">
            <use href="#smallDrop" x="25" y="20">
                <animate attributeName="y" values="20;80" dur="1s" repeatCount="indefinite"/>
            </use>
            <use href="#smallDrop" x="50" y="20">
                <animate attributeName="y" values="20;80" dur="0.85s" repeatCount="indefinite"/>
            </use>
            <use href="#smallDrop" x="75" y="20">
                <animate attributeName="y" values="20;80" dur="0.75s" repeatCount="indefinite"/>
            </use>

            <use href="#rainClouds" x="50" y="50"/>
        </g>

        <g id="Thunderstorm">
            <use href="#p_lightning" transform="scale(0.6)" y="25">
                <animate attributeName="opacity" values="0;1;1;0;1;0;0;1"
                         dur="2s" calcMode="discrete" repeatCount="indefinite"/>
            </use>

            <use href="#Rain"/>
        </g>

        <g id="Snow" transform="translate(-50 -50)">
            <use href="#snowflake" x="25" y="30">
                <animate attributeName="y" values="30;80" dur="1s" repeatCount="indefinite"/>
            </use>
            <use href="#snowflake" x="50" y="30">
                <animate attributeName="y" values="30;80" dur="0.85s" repeatCount="indefinite"/>
            </use>
            <use href="#snowflake" x="75" y="30">
                <animate attributeName="y" values="30;80" dur="0.75s" repeatCount="indefinite"/>
            </use>

            <use href="#lightCloud" x="50" y="50"/>
        </g>

    </defs>


    <!-- Testing -->
<!--    <use href="#Thunderstorm" x="50" y="70"/>-->
    <rect x="0" y="0" width="100" height="100"/>
    <use href="#Rain" x="50" y="50"/>

    <rect x="0" y="100" width="100" height="100"/>
    <use href="#Thunderstorm" x="50" y="150"/>

    <rect x="100" y="100" width="100" height="100"/>
    <use href="#Drizzle" x="150" y="150"/>

    <rect x="100" y="0" width="100" height="100"/>
    <use href="#Clear" x="150" y="50"/>

    <rect x="0" y="200" width="100" height="100"/>
    <use href="#Snow" x="50" y="250"/>

    <use href="#Clouds" x="250" y="50"/>
    <!-- -->

    <!-- Message Box -->
    <mask id="windowMask">
        <rect x="0" y="0" width="1000" height="1000" rx="25" fill="white"/>
        <rect x="350" y="400" width="300" height="200" rx="25" fill="black"/>
    </mask>

    <rect id="messageWindow" x="350" y="400" width="300" height="200" rx="25" fill="aqua"
          style="animation: glowBlue 4s ease infinite"/>

    <text id="messageText" x="505" y="380" mask="url(#windowMask)">Initializing</text>


    <!-- Other components -->
    <circle cx="500" cy="500" r="400" fill="black" mask="url(#windowMask)"/>

    <use href="#moon" x="500" y="700"/>

    <circle id="button" onclick="switchDisplay()" cx="625" cy="300" r="30" stroke="hsl(0, 0%, 22%)" stroke-width="3"/>

</svg>

</body>

</html>

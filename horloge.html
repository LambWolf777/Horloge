<!DOCTYPE html>

<!--
    Nom                     |    id ssh     |       matricule   |
----------------------------------------------------------------|
Matthieu Beauchamp-Boulay   |   beaumatt    |       20234205    |
Zacharie Martel             |   martelza    |       20231059    |
Lien Miro:  https://miro.com/app/board/uXjVO9MT7jA=/
-->

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Horloge</title>

    <!-- Define our functions here -->
    <!-- getTime() void function, changes time in html document -->
    <script>
        window.onload = init;


        // Initializers //////////////////////////////////////////////////////

        function init() {
            initPrimitives();
            
            // testPolarRect()

            updateTime();
            getMeteo();

            setInterval(updateTime, 1000); // every second
            setInterval(getMeteo, 60000); // every minute
        }

        function initPrimitives() {
            finishSun();
        }

        //////////////////////////////////////////////////////////////////////


        // Updaters (macro) //////////////////////////////////////////////////

        function updateTime() {
            let time = getTime()

            // set clock times here ...
        }

        // This is called by getMeteo once we receive API response
        // where meteo is the complete JSON data
        function updateMeteo(meteo) {
            // See https://openweathermap.org/api/one-call-api#example for JSON structure

            moon_phase(meteo["daily"][0]["moon_phase"])
        }

        //////////////////////////////////////////////////////////////////////


        // get Info //////////////////////////////////////////////////////////

        function getMeteo() {
            var url = "https://api.openweathermap.org/data/2.5/onecall?lat=45.5028" +
                "&lon=-73.608&units=metric&lang=fr&appid=4ea015650a69d241ca53c20cda9f14ea"

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    var meteo = JSON.parse(this.responseText);

                    updateMeteo(meteo);
                }
            };
            req.open("GET", url, true);
            req.send();

        }

        function getTime() {
            var now = new Date();

            // This would probably go in the display function
            var listeMois = ["janvier", "février", "mars", "avril", "mai", "juin",
                "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

            let time = {
                "an": now.getFullYear(),
                "mois": now.getMonth(),
                "jour": now.getDate(),

                "h": now.getHours(),
                "min": now.getMinutes(),
                "sec": now.getSeconds()
            }

            // 'testing'
            for (const [key, value] of Object.entries(time)) {
                document.getElementById("x-" + key).innerHTML = value;
            }

            return time
        }

        //////////////////////////////////////////////////////////////////////


        // DOM / micro updaters //////////////////////////////////////////////

        // Il serait peut etre mieux de faire un seul dessin de lune qui s'ajuste ...
        // We could also just set the moon phase to it's closest phase instead of
        //      making 8 presets... but it's inaccurate
        function moon_phase(moonPhase) {
            var moon_name;

            if (moonPhase === 0 || moonPhase === 1) {
                moon_name = 'new moon';
            } else if (moonPhase == 0.25) {
                moon_name = 'first quarter moon';
            } else if (moonPhase == 0.5) {
                moon_name = 'full moon';
            } else if (moonPhase == 0.75) {
                moon_name = 'last quarter moon';
            } else if (moonPhase < 0.25) {
                moon_name = 'waxing crescent';
            } else if (moonPhase < 0.5) {
                moon_name = 'waxing gibous';
            } else if (moonPhase < 0.75) {
                moon_name = 'waning gibous';
            } else {
                moon_name = 'waning crescent';
            }

            // TODO: remove me
            document.getElementById("x-moon_name").innerHTML = moon_name;
            document.getElementById("x-moon_phase").innerHTML = moonPhase;

        }

        //////////////////////////////////////////////////////////////////////


        // SVG Generation ////////////////////////////////////////////////////

        function finishSun() {
            let sun = document.getElementById("p_sun");
            const r = Number(sun.firstElementChild.getAttribute("r"));
            const cx = Number(sun.firstElementChild.getAttribute("cx"));
            const cy = Number(sun.firstElementChild.getAttribute("cy"));

            const spikeCount = 32;
            const increment = 2 * Math.PI / spikeCount;

            for (let i = 0; i < spikeCount; i++) {

                let theta1 = i * increment;
                let thetaMid = (i + 0.5) * increment; // adding above 1 makes it spiral
                let theta2 = (i + 1) * increment;

                let growth = 2;
                if (i % 2 !== 0) {
                    growth = 1.6
                }

                let points = [
                    polarPoint(cx, cy, 0.99 * r, theta1),
                    polarPoint(cx, cy, r * growth, thetaMid),
                    polarPoint(cx, cy, 0.99 * r, theta2)
                ];

                growSVG("p_sun", "polygon", {"points": pointsToAttr(points)})
            }
        }

        //////////////////////////////////////////////////////////////////////


        // Utils /////////////////////////////////////////////////////////////

        // return a [x, y] point,
        // allows to use angles as if we were using a right-handed coordinate
        // system with the svg left-handed system
        // Theta should be given in radians
        function polarPoint(cx, cy, r, theta) {
            let y = cy - r * Math.sin(theta)
            let x = cx + r * Math.cos(theta)
            return [x, y]
        }


        // Return a string of path data for a polar rectangle
        // cx, cy are center coords
        // r is the radius of the inner border dr is the 'depth'
        // theta is the initial angle,
        // See polarPoint info, angles work as in right-handed coords
        //
        // Does NOT work for angles > 180
        // Weird behavior when working with small radius, see testPolarRect
        function polarRect(cx, cy, r, dr, theta, dTheta) {
            let rotX = 0;
            let largeArc = 0;
            let sweep = 1;

            let points = [
                polarPoint(cx, cy, r, theta),
                polarPoint(cx, cy, r + dr, theta),
                polarPoint(cx, cy, r + dr, theta + dTheta),
                polarPoint(cx, cy, r, theta + dTheta)
            ];

            return ["M ", points[0][0], points[0][1]].join(" ")
                 + [" L ", points[1][0], points[1][1]].join(" ")
                 + [" A ", r, r, rotX, largeArc, (sweep-1), points[2][0], points[2][1]].join(" ")
                 + [" L ", points[3][0], points[3][1]].join(" ")
                 + [" A ", r, r, rotX, largeArc, sweep, points[0][0], points[0][1]].join(" ")

        }

        function testPolarRect() {
            for (let r=250; r > 5; r -= 20) {
                const nRects = 6
                const increment = 2 * Math.PI / nRects

                for (let i = 0; i < nRects; i++) {
                    if ( i % 2 === 0) {
                        growSVG("horloge", "path",
                            {
                                "d": polarRect(300, 400, r, 10, i * increment, increment),
                                "fill": "black"
                            }
                            )
                    }
                }
            }
        }


        // take a [x, y] point and return as "x,y"
        function pointToAttr(point) {
            return point[0] + "," + point[1];
        }

        // take and array of points [[x, y] ... ]
        // and as "x,y x2,y2 ..."  (use to set attributes)
        function pointsToAttr(points) {
            let txt = "";
            for (point of points) {
                txt += pointToAttr(point) + " ";
            }
            return txt.slice(0, -1);
        }


        // Add a child element to another svg element and set attributes
        // id is the id of the parent element to be grown
        // tagName is the name of the SVG 'balise' (ex: circle, polygon...)
        // attributes is an object = {
        //                              "attributeName": "attributeValue"
        //                              ... }
        // see finishSun() for example of use
        function growSVG(id, tagName, attributes) {
            let elem = document.getElementById(id);
            let newItem = document.createElementNS(
                "http://www.w3.org/2000/svg", tagName);

            for (const [key, value] of Object.entries(attributes)) {
                newItem.setAttribute(key, value);
            }

            elem.appendChild(newItem);
        }

    </script>


</head>


<body>

<svg id="p_draw" width="0" height="0" viewbox="0 0 100 100">

    <!-- Our primitives here! I encourage the use of the p_ prefix on primitives' ids
    Use a translate to center them around (0, 0) to make scaling/centering easier
     This means that all of or primitives **will be placed by their CENTER position** -->

    <defs>
        <!-- We use this svg space to draw our primitives.
             It also allows predictable behavior of gradients when using userSpaceOnUse (see below) -->

        <!-- userSpaceOnUse allows for the gradient to spread on groups
         (instead of applying to each element) Since it applies to global viewBox space -->
        <!--Inconsistent behavior between Firefox and chrome when not specifying cx, cy...-->
        <radialGradient id="sunGrad" cx="50" cy="50" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="yellow"/>
            <stop offset="100%" stop-color="orange"/>  <!-- Black for testing/example -->
        </radialGradient>

        <g id="p_sun" transform="translate(-50 -50)" fill="url('#sunGrad')">
            <circle r="25" cx="50" cy="50"/>
            <!-- JavaScript completes this -->
        </g>

    </defs>


</svg>


<svg id="horloge" width="600" height="800" viewBox="0 0 600 800">


    <defs>

        <!-- example of use -->
        <!-- Need to create a scaled instance before setting a position ... (If I need to scale that is)-->
        <use xlink:href="#p_sun" transform="scale(2)" id="big_sun"/>

    </defs>

    <!-- Canvas Box -->
    <rect x="1" y="0" width="198" height="200" fill="none" stroke="black" stroke-width="1"/>


    <!-- Finally, I can position correctly with it's center -->
    <use href="#big_sun" x="100" y="100"/>


</svg>

<ul>
    <li>L´année: <span id="x-an"></span></li>
    <li>Mois: <span id="x-mois"></span></li>
    <li>Jour: <span id="x-jour"></span></li>
    <li>Heure: <span id="x-h"></span></li>
    <li>Minute: <span id="x-min"></span></li>
    <li>Seconde: <span id="x-sec"></span></li>
</ul>

<ul>
    <li>Phase de la lune: <span id="x-moon_phase"></span></li>
    <li>Nom de la phase: <span id="x-moon_name"></span></li>
</ul>

</body>

</html>
